## Meeting
Calendar Event Title: Atlas knowledge transfer
Calendar Event Time: 2025-09-09T14:15:00-04:00
Meeting Note Title:Atlas knowledge transfer
Attendees: Neville Jos
Link: https://notes.granola.ai/d/20f04510-4a23-4697-a4cb-c181f4752868

## Transcript
 
Me: How's your first week been? Good. This is better than week two. Much better than week one. Lots of context. I was completely useless. Yeah. Which is not a good feeling this week. I feel like I'm starting to get a handle of where things are. Yeah, fair enough. I think it's hard to be useful. I think it takes like two or three weeks now. We used to do what they called. Are they still doing 7, 14, 21? Yes. I think it's so dumb. Again. It doesn't make any sense. It takes four TVS to get what's happening. I'm glad that's the case, because I'm like, wow. I thought in my head, I was like, day one, I'm shipping an agent. All right. How much has Mitch told you about our current attempts at Atlas and all these other things? And I just saw Granola or I can I have a good understanding of sort of the North Star for Atlas and an understanding, a bit of ideas for what we could do first. I don't have a good understanding maybe of the history. So that might be a good place to start. Yeah. Okay. That's fair. And by the way, anything that you think is useful, as much context as I can. And we kind of go from there. Okay? Well, I'll say this. Generally speaking, anytime we try to do any project or work or team or product or something, that comes from some set of philosophies and beliefs about what we think the future of the world looks like, and then kind of building towards that, And so maybe I'll share some of those and where those come from, and then I have my own takes on them. Different takes on them, but we all kind of align at the end of the day. I think that there's this thing, you know, there's this thing called AI Coming. It's here. There's always many. You know? My philosophical belief about AI and quasi spiritual belief is that it's a gift from the universe. To transition us from some percentage of our work. That was mechanical and made us really sad. And we're saying, okay, we're gonna try to help automate a lot of that stuff. And in that. You know, like Lily just typing the same stuff every day. All that, you know, at least like very mechanical, predictable parts for a museum for. And in that, you. We all end up having to ask a question which is like, what's the point of us? We're not gonna be the hypers of these things, all that stuff. And of course you can. Software engineering and computer accounting. It comes for any job. And so Atlas is some attempt. I think my belief about it is that it's some attempt at internally taking that question and saying, okay, well, What does it look like if we were to automate huge thoughts of different people's professions inside the company, even though we're doing for accounting, but even inside the company? And what would a company structure look like in the case? What would workflow so, like, what would process look like? What would the entire structure of a company look like. And the reason I'd like to do this is one, I think that, yes, there is kind of this quas existential threat that you experience when you first see AI do something you particularly like five years to learn to do in a few minutes, you're like, wow, am I useless? But once you get over that hurdle, Then you get to actually have a really fun day, because most of your day becomes a creative work. You know, like. From software engineering perspective. It used to be that I might have shared this, but I'm obsessed with this idea, which is that used to be that, like, 80, 90% of the day was typing. You know, I would just be typing all day long, and I was the guy in the corner with a hoodie, like, if you give me beer. And pizza, and I will happily code up stuff all day long, and I built an entire career in life out of that. And I'm an AI Came, and it was like, doing the same thing. I know it was a little bit of shock. You know, and some percent of the time was actually, like, thinking about what you're gonna go do. But because there was this, like, constant pressure almost to be like, well, let's go. Whatever. The idea is, it's three months to build a 6 billion. We gotta shop building, start building. We would feel that pressure. Because it would take you if he wants, to build whatever idea you had. So there's this constant, like, race against time. And so you didn't have time to, like, really refine an idea or really clarify it before you just started building it and just running with it. But now with the admin of AI. And its ability to do a lot of just mechanical stuff, which is what, you know, coding is. It's a lot of, like. If you think about construction, I think, what, software as a building. And you know, there's architects. There's, like, project managers, and then there's, like, construction workers. And, you know, coding was a construction worker job. At some level, you just have an idea. Some senior engineer has an idea. You tag up, learn. You have some small ideas as you're typing, and you figured out that lobby job was just typing. And then someday you learn how to be an architect as you build a bunch of stuff you'd like, learn patterns. And all this stuff. There's no architecture school for software engineering. It's more a learned skill. And so. And now the construction workers are robots. And so really, like, you know, the only job really, that exists, I think, in some of those architecture and the project management. And so, you know, I think just the percentage of time that we spend coding versus thinking about what we want to build is now change and shifting. You know, I think that's according down, we'll go as incredibly to zero as we spend all of our time thinking. And that's a lot of our processes. Internally, which we'll talk about tomorrow when we're Lexing or RP process stuff, which will be part of our big tomorrow. Is from that perspective. It's like, look, let's just really take a lot of time to, like, really clarify what we're trying to build, who we're building it for, what the point is, what the marketing is, whatever it is. Because execution time is very, very fast, we can build almost anything in, like, two weeks. And so we don't need to rush that. Like, let's be really, really, really clear about what the trade offs here are. What are the data issues, but whatever. And, like, find a solution that really balances everything. And then. And then once you really, really clearly know that you can execute that with the help of AI in like, a week or two. So let's not rush that. Okay? And so the way this kind of works right now, I don't know if you've done the like, if you've learned about planning these issues. This is where I would like help with that. Was every project has three phases. We'll talk about this more tomorrow. But there's a planning phase. An execution phase. And a delivery phase. And planning is very simple. You're gonna write some doc about what you're gonna do. And you can only move to execution once. There are no open questions about what we're gonna and the point in the beginning parts of this generate as many questions as possible. And the latter end of this is answering all the questions. Possible. And then keep generating more, answering more, keep turning your hands more, until you have no open questions left. Once you have complete clarity as to what you're doing and why you're doing it. And everyone else has completely lied about what you're doing and why you're doing it. You can move to execution. The way we do planning right now is there is two docs for this. One is the project. Scoping dock. Which is more like a PM stock, like very high level, like one of the trade offs kind of stuff. And then there's the technical architecture doc, which is for engineers. That's only. What am I gonna code? How am I coded? What are the infrastructure changes? What are the database changes for the system? So in the last step is gonna be the design. Ers. So if there's an. Sometimes there is design, sometimes there isn't. All three of these need to be done. Well and a timeline. Estimated. In order for planning to be done as well, so you need no open questions. You need a timeline. You needed design in technology scoping in order to move a project to the next phase. Right now, all the engineers take on this work, and we have templates for these documents that need to be updated. When they're updated in, like, four or five months. I made all the templates for these. Without image, and I kind of help all build this process. And the idea is that. You continuously update these documents every time you have a meeting or you have a side conversation, you Granola. And then use the normal notes to continue to keep this up to date. You think that someday, like a PM's job, for example, was to, like, constantly keep the docs up to date, like manual typing it out and manually keeping everything up to date. And now that you have all the AI and all this other stuff, you can dump the transcripts into a thing. We don't have, like, a system to do this, but in theory, we do it actually, literally. I take existing document. I copy it into 03 on the website. Then I take our project template and project scoping document guidelines. Dump that into three. Then I take the transcripts dumped out into 03, and then I say, can you update this doc? And then it regenerates the doc. But you can imagine Cursor doing that at GitHub, which is a cleaner way to do that than it is. Copying basics of automatically. Yeah. Right. Then what we can do is theoretically. Theoretically, this doesn't happen yet, because this is where we're at. But this is where I'll help it personally. Which is you take all this stuff. And you dump it into cursor and you say, do it. If it was good. If this was good. You would just be able to one shot it without any additional help from any engineer. Like that's how we see the transition of engineering work to go. Engineers, I think, should get really good at this. And not like they don't actually have to type. I personally don't have that much this morning. I hold down a key. I've been speaking with her into the computer, and it's just been coding in the background. As I like do other stuff. So that's the workflow you want to generate and create. I have two like, these are detailed questions if you want to get your lunch. Okay. One is just on the whisper. Been like this workflow. Same thing for me. Mitch is obviously like, you know, big username. The problem that I still run into is just like, the context switching, which is like, yes, in theory, you can do something and then do something else while it's doing, you know, writing the code, but just mentally, it's actually hard to do that. Do you have any? It takes a while to practice. I mean, I'm not the best at it, but, like, especially now that agents. Like, it didn't used to be that agents could go off for, like, five, 10 minutes and be productive so you didn't have to do violence. Constitution. The agent would return back. In, like, 30, 60 seconds. What to do? We're now, for the first time ever, getting to the phase rate of, like, five, ten minutes of work. And so, you know, even this morning, I. I literally. We're moving off of Merge to go to Sage Group. Whatever. And I said we're doing. We're moving off of Merge to Sage. Can you Google how Sage works? Can you look at how we did the cookbooks code and write the Sage code exactly like the cookbooks code? That's as much as I told it. And then I left, and I came back and had, like, a thousand lines of code, and I was like, great. Like, I looked at it, I gave the feedback. Wrong, too. Yeah. Yeah. And so while I was doing that, I ran a had a meeting or chatted with folks, came back. And so it's still, it's still a problem. Although it's worth the benefits in your mind are certainly worthwhile. Yeah. You know, we also wanted the company building principles is we want to build you know, one of the. Well, this is another idea we can talk about. But, you know, let's just assume for fun. Like OpenAI Air Cloud. All these people are gonna fight it out to the death. And. And they've built an AI that has infinite intelligence. Infinite context window. And perfect recall. Like, okay, great, like. And you have access to that? What would you want to build if you have that? Like, what would you have to build given that assumption? And so. Because what ends up, I think, with people a lot is they go, oh, AI is not smart. Aspire and you go, yeah, but it gets smarter, so let's just build for the smarter version, and then when it catches up, we're just ready to go. And that's how we build a lot of our engineering. That's why I think we're super ahead of the curves. Because people, when they have smarter and smart, literally, we build so much stuff as swimming. AI will get smart one day. And I remember in, like, march when like, Gemini 2. 5 came out. And poor gold, like, four months worth of code that, like, none of it ever worked. And he literally dropped in Gemini to five. Everything worked. And it was. And we were, like, ready to go from that point on. So that's how we tend to build. And so even for Atlas or anything like that, just assuming that. Okay. It's dumb, sure, but let's just imagine that it's extremely intelligent. How would you build the entire process? Yes. And so, on that note, I'll give you some more thoughts. So my theoretical view is that. I wanna. What I see at some level like Atlas to be is like. You know, we have creativity. And then there's, like, the actual creation of the thing, like you're gonna create the thing we're talking about. And I see the future of a lot of technology oriented jobs to be just speaking things into existence. And then you automate it, actually existing. And like so much of the job becomes sitting around the sofa and chatting and trying to figure as you're literally chatting, it's making the thing that you're talking about. And so what is the infrastructure we need in order to be able to do that? So one of the simplest examples is, like, Granola. Every meeting. Have these templates. So these template docs, for example, I want you to really get to know them so that you can say ok, if the Granola plus the template is printing out a bad scoping document, I would rather go update the template. As opposed to fix the scoping augment. And so it's like, transcript. Plus template. Of this document should lead to this document. And if it doesn't go fix the template and we iterate on the template. Until we know that consistently every transfer and the template is a bunch of rules, it's saying a good project scoping document does this, this, this, this. Talks about this. It talks about this. It generates these kind of open questions. And so this is where I want to go. So that we only focus on transcripts. ATLAS focuses on templates. And then these are auto generated, except maybe design. Sure. You know, and so Atlas owns the template part of this, and then continuously or some way, like, you know, continuously improves on it and has some way to eval it or whatever. I don't know how we get better over that. But there's just some temporal right now that we've built that, you know, I don't think it's that great. But that would be the automation. So we just focus on the transcript part, you know, and then everything, like, literally, I can imagine like a drag and drop it to cursor each time every meeting. Drag and drop into cursor. Cursor has a predefined template setup thing, so it just automatically updates. All the docs creates a PR, maybe to GitHub, you know, save someone. Now, once you have all these docs, now we're gonna take these stocks and. Hold on. Let me just open this and. Maybe this is just my job over the next few weeks, but just if you have an opinion on it. Is. I totally agree with the atlas should be in GitHub. All this should be in code. But we are using tools that are not right. So, like we're using Notion. I don't know where these templates are. They currently in Notion. Or they're right now notion currently not. Okay? So I'd want to put the templates in GitHub. This is my video. Yeah. Very technical aspect of it is that, like in the Atlas folder, there's a photo call tablets, and that's what we're just called a project or something. Project template, right. And cursor roles, if you're familiar. And so when you drop in a transcript, it first of all just knows it's a transcript. It then goes finds the relevant project. Then a plastic rush rules to it, just all that stuff. You don't have to think about any of it, but. You're okay with the idea of being like the team is writing project scoping docs. Or I guess they're not writing anymore. In theory, like generated, but they're editing and reading project skill building docs in GitHub. This is something we've been playing with. So I think about half the counters map have cursor and they use it to edit prompts directly. And so they get. They're changing the code base. I'm also getting practice with that. We believe everyone can learn cursor as a technical tool. We can have training sessions and all that stuff, but at its core, if the Atlas folder is very cleanly maintained and structured well, I think with markdown files, we think. I think I don't keep singly. Sure. Then this. This works really well. Let me just make it. This is what I'm spending my morning on. So it's top of my. Which is today the team has git book. Right. And so. And they also have cursor without quite the team di. Has skip book and they've got cursor. Most people in the eye aren't really using cursor yet. They are using gitbook a little bit. There's. I don't know if mat showed you. There's this problem where, like, the way to display the pages in gitbook. Doesn't actually map with the file structure. Cursor. Yes. And so my like, again, leaning into cursor. Billing. Everyone's gonna learn this. The thought is rip out. Just like, get off of git Buck. Right. Is that. Well, I kind of think that the act. Well, giftbook is an external facing. Documentation page. And so, yes, I would love an agent that takes maybe internal docs and code and the auto updates get booked and stuff, but that may be a separate problem, I think. But would you be okay with me going again at the start of the year team, but, like, in theory being like, hey, DI team. Don't worry about Gitbook anymore. That's not your spot. Everything's in cursor. Like go read Stefan Grisher, edit the progressor. If the Gitbook configuration language is confusing to them, then I wouldn't do that. I would let them be directly get book. Honestly. That might be my homage. Okay, like, if Gitbook. Somehow, I don't know how Gitbook works, but if you use, like, a bunch of YAML files or something crazy. JSON config file or something. I wouldn't have di learn like that. But in the atlas folder for, like, projects, go bedeck and stuff. If it's marked down, I think they can learn markdown. Got you. I wouldn't have them because we have marked out in the as functionality of the website. In our product. And so they kind of can learn markdown. It's not too hard. Sure. But, yeah, I wouldn't have them if it's, like, a language with, like, syntactical sugar and stuff. Then I would. Well, that the. And not to go rabbit hole on this too much. But just like the problem is that in Gitbook, if you, if you just use Gitbook, everything makes sense. If we were to get rid of gitbug and just use cursor, then you could in theory learn markdown or whatever. The problem is when it's like, hey, you have to make edits in cursor, but then you have to go update like a summary MD file to make it show up in gitbook. Otherwise it's a good question. I actually don't know. It also depends on if you want the project scoping documents and all those things to live on GitHub, which is pitching because he's open. I mean, that's the current setup. I was thinking more that, like Atlas would not be accessible to git book. It's not hard to get book or like the atlas document or the. At least these Doc, I don't know about this part of that list. Might not be tied to kick. Okay, it was just like markdown files. It may be, but then we have to come up with the folder structure and file structure, if that makes sense for that naming structure. You know, like, for example, you can put all of these under Q3 goals as, like, a folder structure. And we set up, like, 16 projects. Or no, sorry. More 60 projects. Three balls. And so each of the goals have a folder under Q3 goals. And then you open them. But I don't know how that happens with overlapping to other quarters. Or is it time based? Or is it name based? I don't know what the naming structure is, but I just Then imagine that a bunch of markdown files are to make those. Okay. Okay. I also personally like the repo to be next to our code base, but that's a personal opinion. Because then you can just inside the same loop, we'll go and edit our code, right? Like another aspect of the transcript. Actually, it's a good point. Transcript, plus the templates, plus our code. Which actually has a lot of information as well. Right. So if we can read our code, read the template, read the transcript, it can write, really deposit opens, and it can come with open questions saying, hey, how would this work in this scenario? Because you have this code that does this. Like, we might not have thought of that because we haven't been staring at the code, but. It can come up with questions saying how does the interaction between this scenario work? Because it seems like you haven't spoken about it. So if the markdown files for these are sitting in the same repo as the code and then the rules are set up so that they can explore the code, then do example and the transcript all combined, I think it'll be much cleaner and tighter. Yeah, well, even as, like, sibling repos, it can go. It can kind of go across them. I'm open to that thing. Okay. I just love a monore. I understand. I think that's fair. So this is one aspect of something I wanted to chat about. And just, you know, I think the best way to learn this is to maybe be part of a few. I mean, it'll be around surprise. But I also just watching this process happen, you're on the tail end of the Q3 goal. So we did a lot of scoping, except there was, like, two, three weeks where, like, no one touches any code, really. And they're just scoping the out of stuff. Like, there are a lot of projects with scoping them out, like, really fighting and arguing. And, you know, really clarifying the idea. And then we have these copy documents. Now technical architecture is like less templatized than project hoping. I still like not sure what the structure this should be. So like you know you can read Every linear project has both of these documents available so you can see them and if you ask for folks, they'll give you their transcripts. So you can, like, literally build a data set out of this. I'll like transcripts, templates, documents. And just see how it works. But I don't know if that's how you want to do it, but that's, like, one kind of idea. Everyone has granolas and all that stuff, you know? Okay? So now let's talk about execution. Execution is the other hard part. Ok, so this is all just planning. So if. The way I imagine it is that if Atlas was a great job. We're like again. Over time we'll get better. We're purely transcript world and everything else is auto generated. Now obviously people can go and edit stuff and read it but like as much automated as possible. Right. Actually, I will say there's other thing. This is just a completely other separate call that I just want to think about, which is. On a very personal level, I love small teams. And I don't want to hire a thousand people. I have no desire to do that. And on a pure margin basis for the business. I think it's way better enough. Smaller teams and then a communication spaces. I think it's way better because shot across the room and not have to like, learn everyone's name. So, you know, if you think about how many people, like if you think about this whole process, how many people are we actually replacing in? This is actually a lot of people like communication, blue wise and, and so the just cost savings, like how you can keep the team small and all that stuff, like, that's the focus. Here, like if we can. Because in this world, if everyone's just living in the transcript world, then we are only hiring people, kind of like pure ideation. Collaboration, that kind of stuff. Not like people who are communication blue. And political experts, managers and managers, managers and navigators and all of that stuff, which I understand will still need at some point, maybe at scale I'm fighting against. But as much as possible, I want the company to be very great a company, some of them. So that's where, at least on the product end side. And so that's where we keep that team small. And a lot of ways, you know, one of the things we struggled with hiring engineers, partly because we have high bar. But we haven't hired any engineers in four months. Which is kind of crazy. And actually, we just hired the last. We broke the curse. But the team has like, probably increases output by like 2 to 5x. And so that's us just continuously integrating in more and more AI in lieu of having people to do it right. So as the models got better, as we become more process oriented, as we started using granular transcripts for these, every one of the engineers is outskilling themselves into the. Into the like mechanical elements of broad product managers used to do, or whatever communicators used to do. And so in that we are saving a lot of. So our output is generated. So this thesis kind of works at some level. We just want to continue, push it further. And sorry, one other question related to this jump to execution. Like, in theory, I am with you. That, like, it's like, AI should do all this, and then we're gonna turn it to the execution side. It's gonna execute it in practice, as I'm sure you're familiar. It's like, you learn by executing a lot. And so then it used. To, like, have this feedback loop. How does that fit into our current? Like forgetting the future, but, like, I'll just start current process. Great question. I mean, we need people to know how to code it. So execution then becomes more about not actually typing code. I mean that there's a lot of that, too, but it becomes about patterns. So there's a lot of different ways you could write code. I mean, it's a blend page. In the right. However you want. And so what ends up happening is that if you have AI write code, It'll do whatever it feels like do it. And if you do one thing, one place, one thing, another place, one thing, other place, and then you start building it, destroy it system, which is one, hard to manage, but two, it ends up being that they're not interconnected in a lot of ways. And so what we end up focusing on from the execution standpoint and we put logarithm and Gen 2, is like, what is the patterns. Of the things we're building. And can we solidify those in a very specific way and clear way? Because then if you can solidify the pattern, we can go to the AI and say, hey, just do this project in this pattern. But that needs to be very, very, very clear. And so this is the execution problem. The execution problem is you have to be very strict about the pattern s you're using so that AI does the same type of code everywhere. And if it enters a new space, it'll do something like crazy new thing. Because we've never established a pattern there. And that's where an engineer says, okay, we're gonna take a pause here, and we're trying to figure out what the pattern is here of, like, how we want to handle. This kind of problem. And patterns can be very simple and very complex. Like a pattern that I just established, kind of through. Not that I've encoded it anywhere. Right. So there's cursor rules. Which I think it kind of loosely follows. Plus, like, it looks at a lot of code, like, if you think about context wise, It. Like, it looks at the existing patterns, I think way more as a percentage of total examples than rules. Like, the rules is, like, two pages long or let's just say. And, like, the rules are, I think, kind of bad. We have. We need to make these better. So I would love the Atlas team to help make the rules better, but even beyond that. I think it's reading a lot of our code base, and so it's inferring a lot of the rules more than it is like reading rules. And a lot of times it actually ignores our rules and just does what exists out there. Because it's getting conflicting information. The rule this way. And there's this other part of the code that's saying there's totally other thing. And it's like, well, which one is it? And I think it has biasource. I think that exists. Now I can't tell it. Hey. Well, this is code from a year ago. And, like, we don't do stuff like that anymore. You know, that's not how we do stuff in. And so over the last few months, we've been focused a lot on trying to refactor code base, except it turns out we've written a code like, it's just way too much. Code. Like, we try to refactor. We got, like, 10% through in, like, three months, and it's like, oh, my God. Like, this is actually a living nightmare. So what we ended up doing. Is we took one product and we made it the perfect product. At some level, and we say, this is how we code. And that one right now is called onboarding. I think we're supposed to change the name of it, but I would just take a look at that in our code base, it's called the Onboarding Project. And we did everything in that code base perfectly. And so then the cursor rules should say, look at onboarding when you're. When you're now, look at onboarding about how to code. Something. Onboarding is the whole projects. It's literally an onboarding customer. So creating new clients, creating new accounts. You know, doing all those mapping stuff, all this whatever. But it has database calls, it has API calls. That's all these other elements and so. Which are the same elements that if you. Any other product would have. And so you can start to model stuff after that. So we call. This is called the golden folder project and so this is not the golden folder. Now, I would like every folder to be able to forward, but we'll start with one. And so this style is very, very tightly defined. And I think Nep, who helped build the Golden Project, was not here this week. But you meant last consuming. Update all the rules to reflect all the things in Golder. Now, there will be localized rules. Like, for example, I'm doing something right now where I'm doing some ETL pipeline thing. And it, like, onboarding doesn't have a detail pipeline in it. So there's, like, localized rules to the specific product. So I came up with a rule which is like, you know. I don't know. I'll say this, but, like, if an object is deleted in QuickBooks, we're marked as deleted in our system in a certain way. So if that rule is there for QuickBooks, then I have to do the same rule and sage or zero. So that's like a more localized, but it's almost like an inferred rule. Right. It's not like I'm explicitly slaving a cursor rule that says this. It's more like the fact that I coded the QuickBooks thing in a certain way means that. And then I say code the Sage thing, like the QuickBooks thing. It then repeats that pattern over there. So we came up with a generalized pattern that we think every product should have and that gives AI enough structure to write in a basis way 80% of the time. But within a product there are product specific, like weirdnesses. That then allow for, like, 20% of flexibility. And so in those moments, the engineer who's watching the AI code should just think about that pattern and say, like, hey, does this pattern make sense here? Oh, it's doing some new thing that's not part of. We just never thought about this case. Like, what do you want to do in this scenario? It's not like super super strictly defined. Like, you know, some company. Maybe we'll do something like O function should only be 25 lines. Or our variable name should be like this. Or it's not that strict, but it's more strict in, like, file folder structures. Function structures. A few other things I can talk about why we have so many rules about it, but. But one way to think about it is we have to code in very specific ways also because our code, any code we write, is both accessible by our website. Appbaces.com, which hits some like get post influence. I forget your background. Were you an engineer at any point or not? No, but I mean, I can write a tiny bit of JavaScript, but like, mainly now. All right, so you have like, our website. And this can do a bunch of stuff. It can create stuff. You can delete stuff. You know, you click buttons and all this. Then we have this agent. And the agent is supposed to be able to do anything, and anything includes anything the website can do. So the way our code is structured, as we say, both the website and the agent both use the same functionality. It's called units of work. Okay, so everything in our system is a unit of work. It's a very weird way to code, but we think it's necessarily. In the old days, it was just a website going into coach, even after structure this way. But now that there's almost two entry points into the exact same code base, we want to create a common repository of functionality. Calling you, that's work. And so unit of work would be like creating an accounting book. Or sending the email or something, you know, creating a journal entry, you know. Sure. And so the website, when you click up on the website, it's probably combining three or four units of work to accomplish something, which is the same thing you could ask an agent. So that's how you essentially get the same functionality on both ends. So all I say, the Atlas team. I would love to have a few things on the execution side help. So one is planning out, which I think is probably more important and less technical anyways and probably easier place to start. But in the execution front. Ensuring that our code based rules are very clear, that our code is standardized and all the patterns are established in players so that the likelihood that the AI can one shot given a really great set of these, it can one shot the entire product. Goes way up. Right now. It's again, like a week to two weeks. And I would say that, you know, human intervention is needed, like, 50% of the time or something. So it's not bad. It's not great. We're somewhere in the middle. But I would say another kind of mime. Again, everyone's gonna have different opinions about what Apple should do. For you, sure, sure. Things are. But. But for me. Given this set of information, one shotting, all the right code. With test cases and with all the other infrastructure. And, you know, in just one go would be the North Star. And so then again, then, if that's really true, this is me being very futuristic. Whatever. Yeah. All of the time we're just talking. Yeah. Yeah. All we're doing ever, really. And which is what I think people are. We're just being creative. We're talking about, oh, what's the future and how this is gonna look and what's this interaction and what do we want people to feel like? And there's no objectively correct answer there, as much as some view of what we think the future should look like of our opinion. And we get to, like, live in kind of pure creativity. And then the rest of it's literally an automated pipeline of tabacity. And whenever the automated pipeline in my head breaks, We don't fix the thing as much as we update the rules. Or the patterns. Or the templates. It's all, you know. And then we rerun it. Yeah. If you're spending a ton of time editing the output, it's like there's a problem with the system, but there's. So how do you visualize the system? How do you keep track of the system? How to evaluate the system and how do you ensure that the system is continuously getting better? And upgrading. Itself. You know, how do we keep track of all that information? You know? Our transcripts. The transcripts, templates, rules, patterns. That's all our creativity. Right, because there's no objectively correct pattern as much as subjectively good patterns and templates. Given the context in the business and the accounting and our strategy and how we think about whatever, the AI doesn't know that it doesn't know a good pattern because it doesn't have all the context. Around our business, all the context about how we think about things, all that stuff. So as much as we can encode all that information to templates and rules and whatever, Then it has the necessary context and then one shot the rest of it. This is now getting theoretical on number of deliberately, but just. I'll just say my one thought here is playing that under the future, let's imagine we actually accomplish this. Do you imagine a world in which you actually don't even have to be as good at the first part? Because the execution is so good that you can be like, well, we have, like, three ideas. Instead of debating them, let's just make them. We'll see which one's the best. Yeah, because we don't want to execute on different things. Because you don't want to spend all that time. Right. You want people, Right? Which I'm saying, I mean, depends on. There's a few different views on this. I kind of think that prototyping is kind of interesting. Prototyping is kind of an interesting. In that, like, you get to play with different ideas and stuff, but the moment someone. There's all these other things that happen where it's like you can create it internally because you wouldn't show it externally. By looking, creating different versions of something internally and see how it feels. But yeah, you wouldn't do it external. Yeah. One other thing that I'll just note on the execution is most of those rules and patterns and onboarding, all this stuff is just back end code. Front end code needs a lot of work. This is the element where you actually take this part, Designs. And then automate the front end generation of it. We haven't done any work on this. That is a Q4 project that I would like Ashley, who's our engineering leader for product, to focus on for a lot of reasons. Partly also because we think that the future of our internal agent is that it auto creates front end websites for accountant specific to their case. And so we need to standardize the code base, come up with a rule set. It's come up with patterns, so that when an accountant says, hey, can you build me a tracker that does it just, like, bills you a website that, like, does the tracker. Very cool. Very cool, but we are standardizing the front end. I don't know if Apple shit on it or someone, but I would like someone to think about the fact that we need to get that done. And automating product development is probably where we spend so much of our actual manual typing time, which I would like to get that down to zero. And so that means same thing. Design patterns, language patterns, components, structures, all these other things so that when they add codes, it knows how to code. Correctly upfront. It's way harder because of the visual element. There's, like, infinitely more ways to do it. Yes, yes. I've done a lot of coating and, like, that part is doubled. Yeah, yeah. But you buy. Enterprise sound platform. Very closely. 